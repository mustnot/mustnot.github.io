{"componentChunkName":"component---src-templates-blog-post-js","path":"/Backend/네트워크-관련-용어-정리/","result":{"data":{"site":{"siteMetadata":{"title":"mustnot","author":"[mustnot]","siteUrl":"https://mustnot.github.io","comment":{"disqusShortName":"mustnot","utterances":"mustnot/mustnot.github.io"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"7537be92-b42c-5c46-b435-be8ffcda38b5","excerpt":"HTTPS란 HTTPS (Hyper Text Transfer Protocol over Secure Socker Layer, HTTP over TLS, HTTP over SSL, HTTP Secure)는 웹 통신 프로콜인 HTTP의 보안이 강화된 버전으로 HTTPS는 통신의 인증과 암호화를 위해 개발되어 전자 상거래에서 널리 쓰인다. HTTPS는 소켓 통신에서 일반 텍스트를 이용하는 대신에 SSL이나 TLS…","html":"<h2 id=\"https란\" style=\"position:relative;\"><a href=\"#https%EB%9E%80\" aria-label=\"https란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTPS란</h2>\n<p>HTTPS (Hyper Text Transfer Protocol over Secure Socker Layer, HTTP over TLS, HTTP over SSL, HTTP Secure)는 웹 통신 프로콜인 HTTP의 보안이 강화된 버전으로 HTTPS는 통신의 인증과 암호화를 위해 개발되어 전자 상거래에서 널리 쓰인다.</p>\n<p>HTTPS는 소켓 통신에서 일반 텍스트를 이용하는 대신에 SSL이나 TLS 프로토콜을 통해 세션 데이터를 암호화하여 데이터의 적절한 보호를 보장한다. 보호의 수준은 웹 브라우저에서의 구현 정확도와 서버 소프트웨어, 지원하는 암호화 알고리즘에 달려있다.</p>\n<p>HTTP의 경우 클라이언트가 요청한 페이지를 암호화 되지 않은 상태로 주고 받을 수 있어 HTTP로 만든 홈페이지는 클라이언트와 서버의 네트워크에 침입해 중간에서 정보를 가로챌 수 있는 위험이 상존하는데, HTTPS의 경우 보안성이 매우 강해, 보안이 필요한 은행, 쇼핑몰, 정부사이트 등에서 HTTPS로 된 홈페이지를 사용한다. HTTPS의 암호화는 “클라이언트는 공개키를”, “서버는 서버만 알 수 있는 개인키를” 이용하는 방식으로, 클라이언트가 사이트에 접속하게 되면 공개키를 이용자에게 보내 이를 통해 이용자의 암호화된 정보를 서버에 저장된 개인키로 볼 수 있다.</p>\n<h3 id=\"https에서-제공하는-특징\" style=\"position:relative;\"><a href=\"#https%EC%97%90%EC%84%9C-%EC%A0%9C%EA%B3%B5%ED%95%98%EB%8A%94-%ED%8A%B9%EC%A7%95\" aria-label=\"https에서 제공하는 특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTPS에서 제공하는 특징</h3>\n<ol>\n<li><strong>기밀성</strong> : HTTPS는 인터넷과 같은 공공 매체에서 두 참여자 간의 통신을 보호한다. 예를 들어 HTTPS가 없다면 와이파이 액세스 포티은트를 운영하는 사람은 액세스 포인트를 사용하는 사람이 온라인에서 무언가를 구입했는지, 신용카드와 같은 개인정보 등을 볼 수 있다.</li>\n<li><strong>무결성</strong> : HTTPS는 변조되지 않은 정보로 목적지에 도달하는데, 예를 들어 와이파이가 웹사이트에 광고를 추가하거나 대역폭을 절약하고자 이미지 품질을 저하시키거나, 읽는 기사의 내용을 변조할 수 있지만, HTTPS는 웹사이트를 변조할 수 없도록 한다.</li>\n<li><strong>인증</strong> : HTTPS를 통해 웹사이트의 진위 여부를 확인할 수 있는데, 예를 들어, 와이파이 액세스 포인트를 운영하는 사람이 가짜 웹 사이트를 브라우저에 보낼 수 있다. (DNS 서버 도용)</li>\n</ol>\n<p>ㅤ</p>\n<h2 id=\"ssl-인증서\" style=\"position:relative;\"><a href=\"#ssl-%EC%9D%B8%EC%A6%9D%EC%84%9C\" aria-label=\"ssl 인증서 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SSL 인증서</h2>\n<p>SSL (Secure Socker Layer) 인증서란, SSL를 의미하는 것으로 주고 받은 정보가 암호화되어 있음을 뜻한다. 즉 웹서버와 웹사이트에서 이루어지는 모든 정보 및 데이터의 전송이 <a href=\"https://%EB%A1%9C\">https://로</a> 암호화프로토콜을 통해 안정하게 전송되게 하는 인증서이다.</p>\n<h3 id=\"ssl-인증서의-장점-및-역할\" style=\"position:relative;\"><a href=\"#ssl-%EC%9D%B8%EC%A6%9D%EC%84%9C%EC%9D%98-%EC%9E%A5%EC%A0%90-%EB%B0%8F-%EC%97%AD%ED%95%A0\" aria-label=\"ssl 인증서의 장점 및 역할 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SSL 인증서의 장점 및 역할</h3>\n<p>통신 내용이 노출, 변경되는 것을 방지하고, 클라이언트가 접속하려는 서버가 신뢰할 수 있는 서버인지 확인 가능, SSL 통신에 사용할 공개키를 클라이언트에게 제공한다. 인증서의 내용은 CA의 비공개 키를 이용해서 암호화되어 웹 브라우저에게 제공된다. 주로 서비스 정보 (인증서 발급자, CA의 디지털 서명, 서비스 도메인), 서버측 공개키 등</p>\n<h3 id=\"ssl-인증서의-서비스-보증-방법\" style=\"position:relative;\"><a href=\"#ssl-%EC%9D%B8%EC%A6%9D%EC%84%9C%EC%9D%98-%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%B3%B4%EC%A6%9D-%EB%B0%A9%EB%B2%95\" aria-label=\"ssl 인증서의 서비스 보증 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SSL 인증서의 서비스 보증 방법</h3>\n<ul>\n<li>웹브라우저가 서버에 접속하면 서버는 제일 먼저 인증서를 제공한다.</li>\n<li>브라우저는 인증서를 발급한 CA가 가지고 있는 CA 리스트에 있는지 확인한다.</li>\n<li>리스트에 있다면 해당 CA의 공개키를 이용하여 인증서를 복호화한다.</li>\n<li>인증서를 복호화 할 수 있다는 것은 이 인증서가 CA의 비공개키에 의해서 암호화된 것을 의미한다. 즉 데이터를 제공한 사람의 신원을 보장하게 된다.</li>\n</ul>\n<h3 id=\"ssl-동작-방법\" style=\"position:relative;\"><a href=\"#ssl-%EB%8F%99%EC%9E%91-%EB%B0%A9%EB%B2%95\" aria-label=\"ssl 동작 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SSL 동작 방법</h3>\n<p>공개키 암호 방식은 알고리즘 계산방식이 느린 경향이 있어, SSL은 암호화된 데이터를 전송하기 위해 공개키와 대칭키 암호화 방식을 혼합하여 사용한다.</p>\n<p>안전한 의사소통 채널을 수립할 때는 공개키 암호를 사용하고 이렇게 만들어진 채널을 통해 임시의 무작위 대칭키를 생성 및 교환한다. 해당 대칭키는 나머지 데이터 암호화에 활용한다.</p>\n<ul>\n<li>실제 데이터 암호화 방식 : 대칭키</li>\n<li>상기 대칭키를 서로 공유하기 위한 암호화 방식 : 공개키</li>\n</ul>\n<h3 id=\"ssl-통신-과정\" style=\"position:relative;\"><a href=\"#ssl-%ED%86%B5%EC%8B%A0-%EA%B3%BC%EC%A0%95\" aria-label=\"ssl 통신 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SSL 통신 과정</h3>\n<p>컴퓨터와 컴퓨터가 네트워크를 통해 통신 할 때에는<code class=\"language-text\">핸드쉐이크 -&gt; 세션 -&gt; 세션 종료</code> 과정을 거치는데, 암호화된 HTTP 메시지를 교환하기 전에 클라이언트와 서버는 SSL 핸드쉐이크를 진행한다.</p>\n<p>핸드 쉐이크의 목적</p>\n<ul>\n<li>프로토콜 버전 교환</li>\n<li>양쪽이 알고 있는 pre master secret 키 생성 및 교환</li>\n<li>양쪽의 신원 인증</li>\n<li>채널을 암호화 하기 위한 임시 세션 키 생성</li>\n</ul>\n<h3 id=\"ssl에서-사용하는-암호화-종류\" style=\"position:relative;\"><a href=\"#ssl%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%95%94%ED%98%B8%ED%99%94-%EC%A2%85%EB%A5%98\" aria-label=\"ssl에서 사용하는 암호화 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SSL에서 사용하는 암호화 종류</h3>\n<ul>\n<li>암호 : 텍스트를 아무나 읽지 못하도록 인코딩하는 알고리즘</li>\n<li>키 : 암호의 동작을 변경하는 매개변수, 키에 따라 암호화 결과가 달라지기 때문에 키를 모르면 복호화가 불가능하다.</li>\n</ul>\n<h3 id=\"대칭키-암호화-방식\" style=\"position:relative;\"><a href=\"#%EB%8C%80%EC%B9%AD%ED%82%A4-%EC%95%94%ED%98%B8%ED%99%94-%EB%B0%A9%EC%8B%9D\" aria-label=\"대칭키 암호화 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>대칭키 암호화 방식</h3>\n<ul>\n<li>인코딩과 디코딩에 같은 키를 사용하는 알고리즘</li>\n<li>단점 : 발송자와 수신자가 서로 대화하려면 둘 다 공유키를 가져야 한다.</li>\n<li>대칭키를 전달하는 과정에서 키가 유출이 되면 암호의 내용을 복호화할 수 있기 때문에 위험하다.</li>\n<li>이를 보완하기 위해 나온 방법이 공개키 암호화 방식</li>\n</ul>\n<h3 id=\"공개키-암호화-방식\" style=\"position:relative;\"><a href=\"#%EA%B3%B5%EA%B0%9C%ED%82%A4-%EC%95%94%ED%98%B8%ED%99%94-%EB%B0%A9%EC%8B%9D\" aria-label=\"공개키 암호화 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>공개키 암호화 방식</h3>\n<ul>\n<li>인코딩과 디코딩에 다른 키를 사용하는 알고리즘</li>\n<li>A키로 암호화하면 B키로 복호화할 수 있다. 그 반대 역시 가능</li>\n<li>인코딩 키 (Public Key)는 공개되어 있으며, 보통 디지털 인증서 안에 포함되어 있다.</li>\n<li>디코딩 키 (Secret Key)는 호스트만이 개인 디코딩 키를 알고 있다.</li>\n<li>공개키와 비공개키의 분리는 메시지 인코딩은 누구나 할 수 있도록 해주는 동시에, 메시지의 디코딩을 비밀키 소유자에게만 부여한다.</li>\n<li>이는 클라이언트가 서버로 안전하게 메시지를 발송하는 것을 쉽게 해준다.</li>\n<li>단점 : 공개키 암호화 방식의 알고리즘을 계산이 느린 경향이 있다.</li>\n</ul>\n<h3 id=\"디지털-서명\" style=\"position:relative;\"><a href=\"#%EB%94%94%EC%A7%80%ED%84%B8-%EC%84%9C%EB%AA%85\" aria-label=\"디지털 서명 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>디지털 서명</h3>\n<ul>\n<li>전자 서명을 통해 누가 메시지를 썻고 메시지가 위조되지 않았음을 증명하는데 사용되며, SSL 인증서에서 서비스를 보증하는 방법으로 활용된다.</li>\n<li>공개키와 비공개키는 안전한 데이터 전달 이외에도, 데이터 제공자의 신원을 보장 하는데 사용할 수 있다.</li>\n<li>\n<p>순서</p>\n<ol>\n<li>비공개키의 소유자가 비공개 키를 이용해서 정보를 암호화</li>\n<li>공개키와 함께 암호화된 정보를 전송</li>\n<li>수신자는 공개키로 암호환된 정보를 복호화</li>\n</ol>\n</li>\n<li>암호화된 데이터를 공개키를 가지고 복호화 할 수 있다는 것은 그 데이터가 공개키와 쌍을 이루는 비공개키에 의해서 암호화가 되었다는 것을 의미한다.</li>\n<li>즉 공개키가 데이터를 제공한 사람의 신원을 보장해주게 되는 것이다.</li>\n</ul>\n<h3 id=\"ca-certificate-authority\" style=\"position:relative;\"><a href=\"#ca-certificate-authority\" aria-label=\"ca certificate authority permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CA (Certificate Authority)</h3>\n<ul>\n<li>디지털 인증서를 제공하는 공인된 기업 (Certificate Authority 혹은 Root Certificate)</li>\n<li>\n<p>대표적인 CA 서비스 제공 기업</p>\n<ul>\n<li>Symantec</li>\n<li>Comodo</li>\n<li>GoDaddy</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"jwt란\" style=\"position:relative;\"><a href=\"#jwt%EB%9E%80\" aria-label=\"jwt란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT란?</h2>\n<p>JWT은 웹표준으로서 두 개체 사이에서 JSON 객체를 사용하여 가볍고 자가수용적인 방식으로 정보를 <strong>안전성</strong> 있게 전달한다. JWT에 대해 알아보기 전에 JSON에 대해 알아보자.</p>\n<p>JSON (JavaScript Object Notation) 은 속성-값 쌍 혹은 키-값 쌍으로 이루어진 데이터 오브젝트를 전달하기 위해 인간이 읽을 수 있는 텍스트를 사용하는 개방형 표준 포맷이다. 비동기 브라우저/서버 통신 (Ajax)를 위해 넓게는 XML을 대체하는 주요 데이터 포맷이다. 특히 인터넷에서 자료를 주고 받을 때 그 자료를 표현하는 방법으로 알려져 있으며, 자료의 종류에는 큰 제한이 없어 변수값을 표현하는데 적합하다.</p>\n<p>ㅤ</p>\n<h2 id=\"구성-요소\" style=\"position:relative;\"><a href=\"#%EA%B5%AC%EC%84%B1-%EC%9A%94%EC%86%8C\" aria-label=\"구성 요소 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>구성 요소</h2>\n<p>JWT는 <code class=\"language-text\">.</code>을 구분자로 3가지의 문자열로 구성되어 있다.</p>\n<p>예) aaaa.bbbbb.cccc</p>\n<ul>\n<li>헤더 (header) : aaaaa</li>\n<li>내용 (payload) : bbbbb</li>\n<li>서명 (signature) : ccccc</li>\n</ul>\n<p>ㅤ</p>\n<h3 id=\"헤더-header\" style=\"position:relative;\"><a href=\"#%ED%97%A4%EB%8D%94-header\" aria-label=\"헤더 header permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>헤더 (header)</h3>\n<p>헤더는 <code class=\"language-text\">typ</code>, <code class=\"language-text\">alg</code> 두 가지의 정보를 지니고 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"typ\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"JWT\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"alg\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"HS256\"</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>typ : 토큰의 타입을 지정 JWT이기에 “JWT”라는 값이 들어간다.</li>\n<li>alg : 해싱 알고리즘을 지정 HMAC, SHA256, RSA가 사용되면 토근을 검증할 때 사용되는 signature 부분에서 사용된다.</li>\n</ul>\n<p>ㅤ</p>\n<h3 id=\"정보-payload\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%B3%B4-payload\" aria-label=\"정보 payload permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정보 (Payload)</h3>\n<p>Payload 부분에는 토큰을 담을 정보가 들어있다. 정보의 한 조각을 클레임(claim)이라고 부르고, 이는 name/value의 한 쌍으로 이뤄져있다. 토큰에는 여러 개의 클레임들을 넣을 수 있지만 많아질수록 토큰의 길이가 길어진다.</p>\n<p>클레임의 종류는 크게 세 분류로 나누어진다.</p>\n<ol>\n<li>\n<p><strong>등록된 (registered) 클레임</strong> : 서비스에서 필요한 정보들이 아닌, 토큰에 대한 정보들을 담기 위하여 이름이 이미 정해진 클레임이다. 등록된 클레임의 사용은 모두 선택(optional)이며, 이에 포함된 클레임은 다음과 같다.</p>\n<ul>\n<li><code class=\"language-text\">iss</code> : 토큰 발급자 (issuer)</li>\n<li><code class=\"language-text\">sub</code> : 토큰 제목 (subject)</li>\n<li><code class=\"language-text\">aud</code> : 토큰 대상자 (audience)</li>\n<li><code class=\"language-text\">exp</code> : 토큰의 만료시간(expiration), 시간은 NumericDate 형식으로 되어있어야 하며 언제나 현재 시간보다 이후로 설정되어 있어야 합니다.</li>\n<li><code class=\"language-text\">nbf</code> : Not before을 의미하며, 토큰의 활성 날짜와 비슷한 개념입니다. 여기에도 NumericDate형식으로 날짜를 지정하며, 이 날짜가 지정하며, 이 날짜가 지나기 전까지는 토큰이 처리되지 않습니다.</li>\n<li><code class=\"language-text\">iat</code> : 토큰이 발급된 시간(issued at), 이 값을 사용하여 토큰의 age가 얼마나 되었는지 판단 할 수 있습니다.</li>\n<li><code class=\"language-text\">jti</code> : JWT의 고유 식별자로서, 주로 중복적인 처리를 방지하기 위하여 사용됩니다. 일회용 토큰에 사용하면 유용합니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>공개 (public) 클레임</strong> : 공개 클ㅋ레임들은 충돌이 방지된 (collision-resistant) 이름을 가지고 있어야한다. 충돌을 방지하기 위해서는 클레임의 이름을 URL 형식으로 짓는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n <span class=\"token property\">\"https://aaa.com/jwt/is-active\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li><strong>비공개 (private) 클레임</strong> : 양 측간에 (보통 클라이언트와 서버) 합의하에 사용되는 클레임 이름들로 공개 클레임과는 달리 이름이 중복되어 충돌이 될 수 있으니 사용할 때 유의해야한다.</li>\n</ol>\n<p>ㅤ</p>\n<h3 id=\"서명-signatue\" style=\"position:relative;\"><a href=\"#%EC%84%9C%EB%AA%85-signatue\" aria-label=\"서명 signatue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>서명 (signatue)</h3>\n<p>서명은 헤더의 인코딩 값과 정보의 인코딩 값을 합친 후 주어진 비밀키로 해쉬를 하여 생성한다. 이렇게 만들어진 해쉬를 <code class=\"language-text\">base64</code> 형태로 나타낸다.</p>\n<h2 id=\"로그인-인증시-jwt-사용\" style=\"position:relative;\"><a href=\"#%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EC%9D%B8%EC%A6%9D%EC%8B%9C-jwt-%EC%82%AC%EC%9A%A9\" aria-label=\"로그인 인증시 jwt 사용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>로그인 인증시 JWT 사용</h2>\n<p>로그인 인증시에도 JWT를 사용한다. 주로 세션을 유지하기 위해서 사용하는데, 이 때 만약 유효기간이 짧은 Token을 발급하게 되면 사용자 입장에서 자주 로그인을 해야하기 때문에 번거롭고 반대로 유효기간이 긴 Token을 발급하게되면 제 3자에게 토큰을 탈취당할 수 있는 보안에 취약하다는 단점이 존재한다.</p>\n<p>이런 점을 보완하기 위해 Refresh Token을 사용하는데, Refresh Token은 앞서 로그인에서 발급했던 Access Token과 동일한 JWT 라는 점에서 Access Token의 유효기간이 만료되었을 때, Refresh Token이 새로 발급해주는 열쇠 역할을 한다. 예를 들어, Refresh Token의 유효기간은 1주, Access Token의 유효기간은 1시간이라고 한다면, 사용자는 Access Token으로 1시간동안 API요청을 하다가 시간이 만료되면 Refresh Token을 이용하여 새롭게 발급하면 된다.</p>\n<p>이 방법또한 Access Token이 탈취당한다해도 정보가 유출이 되는걸 막을 수 없지만, 더 짧은 유효기간때문에 탈취되는 가능성이 적다는 점을 이용한 것으로 Refresh Token 또한 유효기간이 만료됐다면, 사용자는 새로 로그인해야 하며, Refresh Token도 탈취 될 가능성이 있기 때문에 적절한 유효기간 설정이 필요하다.</p>\n<br>\n<h2 id=\"tcpudp\" style=\"position:relative;\"><a href=\"#tcpudp\" aria-label=\"tcpudp permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TCP/UDP</h2>\n<h3 id=\"udp-user-datagram-protocol\" style=\"position:relative;\"><a href=\"#udp-user-datagram-protocol\" aria-label=\"udp user datagram protocol permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>UDP (User Datagram Protocol)</h3>\n<p>UDP(User Datagram Protocol)란, 사용자 데이터그램 프로토콜로 <strong>비연결성 프로토콜</strong> 이다. IP 데이터 그램을 캡슐화하여 보내는 방법과 연결 설정을 하지 않고 보내는 방법을 제공한다. <code class=\"language-text\">UDP</code> 는 흐름제어, 오류제어 또는 손상된 세그먼트의 수신에 대한 재전송을 하지 않는다. 이 모두가 사용자 프로세스의 몫으로, UDP가 행하는 것은 포트를 사용하여 IP 프로토콜에 인터페이스를 제공한다.</p>\n<p>종종 클라이언트는 서버로 짧은 요청을 보내거나, 짧은 응답을 원한다. 만약 이 때 요청 또는 응답이 손실된다면, 클라이언트는 time out으로 다시 시도할 수 있으면 된다. 코드가 간단할 뿐만 아니라 TCP 처럼 초기 설정 (initial setup) 에서 요구되는 프로토콜보다 적은 메시지가 요구된다.</p>\n<p><code class=\"language-text\">UDP</code> 를 사용하는 것 중 대표적인 것으로 <code class=\"language-text\">DNS</code>가 있는데, 어떤 호스트 네임의 IP 주소를 찾을 필요가 있는 프로그램은, DNS 서버로 호스트 네임을 포함한 UDP 패킷을 보낸다. 이 서버는 호스트의 IP 주소를 포함한 UDP 패킷으로 응답하는데, 사전에 어떠한 설정도 필요하지 않으며 그 후에 해제가 필요하지 않다.</p>\n<p><strong>UDP</strong>가 특별히 유용한 분야는 클라이언트-서버 상황인데, 그러다보니 대표적으로 DNS가 있는 것이다. DNS 서버는 주로 클라이언트의 짧은 요청에 짧은 응답으로 빠른 인터넷 연결을 지원한다.</p>\n<h3 id=\"tcp-transmission-control-protocol\" style=\"position:relative;\"><a href=\"#tcp-transmission-control-protocol\" aria-label=\"tcp transmission control protocol permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TCP (Transmission Control Protocol)</h3>\n<p>TCP(Transmission Control Protocol)란, 전송 제어 프로토콜로 UDP와 달리 “제어”라는 단어가 들어간 프로토콜이다. 대부분의 인터넷 응용 분야에서는 <strong>신뢰성</strong>과 <strong>순차적인 전달</strong>을 필요로 하는데, 단순히 보내고 받기만 하는 UDP는 이를 만족할 수 없다. 그래서 탄생한 것이 TCP이다. TCP는 신뢰성이 없는 인터넷을 통해 종단간에 신뢰성 있는 바이트 스트림을 전송하도록 특별히 설계되어, TCP 서비스는 송신사와 수신자 모두가 소켓이라고 부르는 종단점을 생성함으로써 이루어진다. TCP에서 연결 설정 (Connection Establishment)는 <code class=\"language-text\">3-way handshake</code> 를 통해 행해진다.</p>\n<p>모든 TCP 연결은 전이중(full-duplex), 점대점(point-to-point) 방식으로 연결된다.</p>\n<ul>\n<li>전이중 : 전송이 양방향으로 동시에 일어날 수 있음을 의미하며, 데이터를 요청하기만 하는 것이 아니라 양방향 간 커뮤니케이션이 가능하다.</li>\n<li>점대점 : 각 연결이 정확히 2개의 종단점을 가지고 있음을 말한다.</li>\n</ul>\n<p>TCP는 멀티캐스팅이나 브로드캐스팅을 지원하지 않는다.</p>\n<h3 id=\"tcp-3-way-handshake\" style=\"position:relative;\"><a href=\"#tcp-3-way-handshake\" aria-label=\"tcp 3 way handshake permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TCP 3 way handshake</h3>\n<p>TCP는 정확한 전송을 보장해야한다. 앞서 설명한 것처럼, TCP가 신뢰성의 필요로 인해 탄생한 것이기 때문에 논리적인 접속을 성립하기 위해 <code class=\"language-text\">3 way handshake</code> 과정을 진행한다.</p>\n<ol>\n<li>클라이언트가 서버에게 SYN 패킷을 보냄 (sequence: x)</li>\n<li>서버가 SYN(x)를 받고, 클라이언트에게 받았다는 신호인 ACK와 SYN 패킷을 보냄 (sequence: y, ACK: x+1)</li>\n<li>클라이언트는 서버의 응답을 ACK(x+1)와 SYN(y) 패킷을 받고, ACK(y+1)을 서버로 보냄</li>\n</ol>\n<p>이렇게 3번의 통신이 모두 완료되면 연결이 성립된다.</p>\n<br>\n<h1 id=\"csrf란\" style=\"position:relative;\"><a href=\"#csrf%EB%9E%80\" aria-label=\"csrf란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CSRF란?</h1>\n<p><strong>CSRF</strong> (Cross-site Request Forgery) 사이트 간 요청 위조로 <strong>웹사이트 취약점 공격</strong> 중 하나로, 사용자가 자신의 의지와 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 특정 웹사이트에 요청하게 하는 공격을 말한다. 다른 말로는 크로스 사이트 요청 위조(XSRF)라고도 부른다.</p>\n<p><strong>사이트 간 스크립팅(XSS)</strong>를 이용한 공격이 사용자가 특정 웹사이트를 신용하는 점을 노린 것이라면, <strong>CSRF</strong>는 특정 웹사이트가 사용자의 웹 브라우저를 신용하는 상태를 노린 것이다. 일단 사용자가 웹사이트에 로그인한 상태에서 사이트간 요청 위조 공격 코드가 삽입된 페이지를 열면, 공격 대상이 되는 웹사이트는 위조된 공격 명령이 믿을 수 있는 사용자로부터 발송된 것으로 판단하게 되어 공격에 노출된다.</p>\n<blockquote>\n<p>결국 CSRF는 웹 사이트가 사용자를 믿을 수 있다고 판단해놓았을 때 위조된 공격 명령을 사용자로부터 발송하여 공격하는 방법으로 보인다. (맞나 모르겠네)</p>\n</blockquote>\n<h2 id=\"공격-과정\" style=\"position:relative;\"><a href=\"#%EA%B3%B5%EA%B2%A9-%EA%B3%BC%EC%A0%95\" aria-label=\"공격 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>공격 과정</h2>\n<ol>\n<li>이용자(사용자)는 웹사이트에 로그인하여 정상적인 <strong>쿠키</strong>를 발급받는다.</li>\n<li>\n<p>공격자는 다음과 같은 <strong>링크</strong>를 이메일이나 게시판 등의 경로를 통해 이용자에게 전달한다.</p>\n<ul>\n<li><code class=\"language-text\">http://www.geocities.com/attacker</code></li>\n</ul>\n</li>\n<li>공격용 HTML 페이지는 다음과 같은 이미지 태그를 가진다.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>img</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>https://travel.service.com/travel_update?.src=Korea&amp;.dst=Hell<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span></code></pre></div>\n<ol start=\"4\">\n<li>이용자가 공격용 페이지를 열면, 브라우저는 이미지 파일을 받아오기 위해 공격용 URL을 연다.</li>\n<li>이용자의 승인이나 인지 없이 출발지와 도착지가 등록됨으로써 공격이 완료된다. 해당 서비스 페이지는 등록 과정에 대해 단순히 쿠키를 통한 본인확인 밖에 하지 않으므로 공격자가 정상적인 이용자의 수정이 가능하게 된다.</li>\n</ol>\n<br>\n<h3 id=\"예시\" style=\"position:relative;\"><a href=\"#%EC%98%88%EC%8B%9C\" aria-label=\"예시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>예시</h3>\n<blockquote>\n<p>나만 그럴수도 있겠지만, 위에 공격 과정만 들었을 때에는 이해하지 못했다. 그래서 예시를 찾아 내가 이해한 내용대로 설명하면 다음과 같다.</p>\n</blockquote>\n<p>공격 혹은 해킹에 대표적인 예시가 바로 고객의 패스워드를 강제로 변경하는 방법인데, 이를 예시로 들면 특정 웹사이트가 존재하는데 해당 웹사이트에 <u>로그인</u>한 사용자가 패스워드를 변경하고자 하면 일련의 과정을 거치게 되는데, 만약 해당 주소의 패턴이 있어 누구나 위변조가 가능하다면 특정 사용자에게 강제로 패스워드 변경이 가능한 주소를 전달하여 접속하게 하여 사용자의 패스워드를 강제로 변경시켜 공격하는 방법이다.</p>\n<p>음 조금 헷갈릴 수 있는데, 예를 들면 우리가 일반적으로 로그인하는 shopping.com 사이트가 있다고 하면 고객이 패스워드 변경하고자 하면 일련의 과정을 거쳐 패스워드 변경이 가능하다. 하지만 이런 과정에서 url이 공개되어 shopping.com/user.pswd_change?pwd=1111 이라는 주소에 접속하기만 하더라도 접속한 사용자의 패스워드가 변경된다면, 이런 URL을 자유게시판이나 누구나 접근 가능한 곳에 공개하여 접속하게 유도하는 방식이다. (맞는지 모르겠다.)</p>\n<br>\n<br>\n<h2 id=\"방어-방법\" style=\"position:relative;\"><a href=\"#%EB%B0%A9%EC%96%B4-%EB%B0%A9%EB%B2%95\" aria-label=\"방어 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>방어 방법</h2>\n<blockquote>\n<p>찾아보니 결국엔 Back 단과 상호 작용이 필요해보인다. 웹에서는 한계가 있는 듯하다.</p>\n</blockquote>\n<h3 id=\"referrer-검증\" style=\"position:relative;\"><a href=\"#referrer-%EA%B2%80%EC%A6%9D\" aria-label=\"referrer 검증 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Referrer 검증</h3>\n<p>사용자 요청의 referrer를 확인하여 domain이 기존 요청과 일치하는지 검증하는 방법이 있다. 일반적으로 referrer 검증만으로도 대부분의 CSRF 공격을 방어할 수 있는데, 위 공격 방법만 보더라도 동일한 도메인을 쓰는걸로 봐서 이 방법 역시 취약점이 있다면 공격을 당할 수 있다는 점이 있어보인다.</p>\n<br>\n<h3 id=\"csrf-token\" style=\"position:relative;\"><a href=\"#csrf-token\" aria-label=\"csrf token permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CSRF Token</h3>\n<p>사용자 세션에 임의의 난수 값을 저장하고 사용자 요청마다 해당 난수 값을 포함 시켜 전송시킨 후에 Back-End 에서 요청 받을 때마다 세션에 저장된 토큰 값과 파라미터에 전달되는 토큰 값이 일치하는지 검증 하는 방법이다. 쉽게 말하면 결국엔 사용자 세션에다가 임의의 토큰 값을 저장하여 특정 요청 시마다 토큰을 비교 검증하여 허용하는 방법으로 볼 수 있는데, 이 방법 역시 취약점이 있을 경우 강제로 검증 결과를 True로 바꾸는 등에 방법을 통해 공격 당할 수 있다.</p>","frontmatter":{"title":"네트워크 관련 용어 정리","date":"October 23, 2020"}}},"pageContext":{"slug":"/Backend/네트워크-관련-용어-정리/","previous":{"fields":{"slug":"/Backend/ci-cd-pipeline이란/"},"frontmatter":{"title":"CI/CD Pipeline이란","category":"Backend","draft":false}},"next":{"fields":{"slug":"/Kafka/aws-ec2에-kafka-cluter-구성/"},"frontmatter":{"title":"AWS EC2에 Kafka Cluter 구성","category":"Kafka","draft":false}}}},"staticQueryHashes":["2486386679","3128451518"]}