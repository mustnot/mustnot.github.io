{"componentChunkName":"component---src-templates-blog-post-js","path":"/Backend/네트워크-관련-용어-정리/","result":{"data":{"site":{"siteMetadata":{"title":"MUSTNOT","author":"[mustnot]","siteUrl":"https://mustnot.github.io","comment":{"disqusShortName":"","utterances":"mustnot/mustnot.github.io"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"7537be92-b42c-5c46-b435-be8ffcda38b5","excerpt":"HTTPS란 HTTPS (Hyper Text Transfer Protocol over Secure Socker Layer, HTTP over TLS, HTTP over SSL, HTTP Secure)는 웹 통신 프로콜인 HTTP의 보안이 강화된 버전으로 HTTPS는 통신의 인증과 암호화를 위해 개발되어 전자 상거래에서 널리 쓰인다. HTTPS는 소켓 통신에서 일반 텍스트를 이용하는 대신에 SSL이나 TLS…","html":"<h2 id=\"https란\" style=\"position:relative;\"><a href=\"#https%EB%9E%80\" aria-label=\"https란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTPS란</h2>\n<p>HTTPS (Hyper Text Transfer Protocol over Secure Socker Layer, HTTP over TLS, HTTP over SSL, HTTP Secure)는 웹 통신 프로콜인 HTTP의 보안이 강화된 버전으로 HTTPS는 통신의 인증과 암호화를 위해 개발되어 전자 상거래에서 널리 쓰인다.</p>\n<p>HTTPS는 소켓 통신에서 일반 텍스트를 이용하는 대신에 SSL이나 TLS 프로토콜을 통해 세션 데이터를 암호화하여 데이터의 적절한 보호를 보장한다. 보호의 수준은 웹 브라우저에서의 구현 정확도와 서버 소프트웨어, 지원하는 암호화 알고리즘에 달려있다.</p>\n<p>HTTP의 경우 클라이언트가 요청한 페이지를 암호화 되지 않은 상태로 주고 받을 수 있어 HTTP로 만든 홈페이지는 클라이언트와 서버의 네트워크에 침입해 중간에서 정보를 가로챌 수 있는 위험이 상존하는데, HTTPS의 경우 보안성이 매우 강해, 보안이 필요한 은행, 쇼핑몰, 정부사이트 등에서 HTTPS로 된 홈페이지를 사용한다. HTTPS의 암호화는 “클라이언트는 공개키를”, “서버는 서버만 알 수 있는 개인키를” 이용하는 방식으로, 클라이언트가 사이트에 접속하게 되면 공개키를 이용자에게 보내 이를 통해 이용자의 암호화된 정보를 서버에 저장된 개인키로 볼 수 있다.</p>\n<h4 id=\"https에서-제공하는-특징\" style=\"position:relative;\"><a href=\"#https%EC%97%90%EC%84%9C-%EC%A0%9C%EA%B3%B5%ED%95%98%EB%8A%94-%ED%8A%B9%EC%A7%95\" aria-label=\"https에서 제공하는 특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTPS에서 제공하는 특징</h4>\n<ol>\n<li><strong>기밀성</strong> : HTTPS는 인터넷과 같은 공공 매체에서 두 참여자 간의 통신을 보호한다. 예를 들어 HTTPS가 없다면 와이파이 액세스 포티은트를 운영하는 사람은 액세스 포인트를 사용하는 사람이 온라인에서 무언가를 구입했는지, 신용카드와 같은 개인정보 등을 볼 수 있다.</li>\n<li><strong>무결성</strong> : HTTPS는 변조되지 않은 정보로 목적지에 도달하는데, 예를 들어 와이파이가 웹사이트에 광고를 추가하거나 대역폭을 절약하고자 이미지 품질을 저하시키거나, 읽는 기사의 내용을 변조할 수 있지만, HTTPS는 웹사이트를 변조할 수 없도록 한다.</li>\n<li><strong>인증</strong> : HTTPS를 통해 웹사이트의 진위 여부를 확인할 수 있는데, 예를 들어, 와이파이 액세스 포인트를 운영하는 사람이 가짜 웹 사이트를 브라우저에 보낼 수 있다. (DNS 서버 도용)</li>\n</ol>\n<p>ㅤ</p>\n<h2 id=\"ssl-인증서\" style=\"position:relative;\"><a href=\"#ssl-%EC%9D%B8%EC%A6%9D%EC%84%9C\" aria-label=\"ssl 인증서 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SSL 인증서</h2>\n<p>SSL (Secure Socker Layer) 인증서란, SSL를 의미하는 것으로 주고 받은 정보가 암호화되어 있음을 뜻한다. 즉 웹서버와 웹사이트에서 이루어지는 모든 정보 및 데이터의 전송이 <a href=\"https://%EB%A1%9C\">https://로</a> 암호화프로토콜을 통해 안정하게 전송되게 하는 인증서이다.</p>\n<h3 id=\"ssl-인증서의-장점-및-역할\" style=\"position:relative;\"><a href=\"#ssl-%EC%9D%B8%EC%A6%9D%EC%84%9C%EC%9D%98-%EC%9E%A5%EC%A0%90-%EB%B0%8F-%EC%97%AD%ED%95%A0\" aria-label=\"ssl 인증서의 장점 및 역할 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SSL 인증서의 장점 및 역할</h3>\n<p>통신 내용이 노출, 변경되는 것을 방지하고, 클라이언트가 접속하려는 서버가 신뢰할 수 있는 서버인지 확인 가능, SSL 통신에 사용할 공개키를 클라이언트에게 제공한다. 인증서의 내용은 CA의 비공개 키를 이용해서 암호화되어 웹 브라우저에게 제공된다. 주로 서비스 정보 (인증서 발급자, CA의 디지털 서명, 서비스 도메인), 서버측 공개키 등</p>\n<h3 id=\"ssl-인증서의-서비스-보증-방법\" style=\"position:relative;\"><a href=\"#ssl-%EC%9D%B8%EC%A6%9D%EC%84%9C%EC%9D%98-%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%B3%B4%EC%A6%9D-%EB%B0%A9%EB%B2%95\" aria-label=\"ssl 인증서의 서비스 보증 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SSL 인증서의 서비스 보증 방법</h3>\n<ul>\n<li>웹브라우저가 서버에 접속하면 서버는 제일 먼저 인증서를 제공한다.</li>\n<li>브라우저는 인증서를 발급한 CA가 가지고 있는 CA 리스트에 있는지 확인한다.</li>\n<li>리스트에 있다면 해당 CA의 공개키를 이용하여 인증서를 복호화한다.</li>\n<li>인증서를 복호화 할 수 있다는 것은 이 인증서가 CA의 비공개키에 의해서 암호화된 것을 의미한다. 즉 데이터를 제공한 사람의 신원을 보장하게 된다.</li>\n</ul>\n<h3 id=\"ssl-동작-방법\" style=\"position:relative;\"><a href=\"#ssl-%EB%8F%99%EC%9E%91-%EB%B0%A9%EB%B2%95\" aria-label=\"ssl 동작 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SSL 동작 방법</h3>\n<p>공개키 암호 방식은 알고리즘 계산방식이 느린 경향이 있어, SSL은 암호화된 데이터를 전송하기 위해 공개키와 대칭키 암호화 방식을 혼합하여 사용한다.</p>\n<p>안전한 의사소통 채널을 수립할 때는 공개키 암호를 사용하고 이렇게 만들어진 채널을 통해 임시의 무작위 대칭키를 생성 및 교환한다. 해당 대칭키는 나머지 데이터 암호화에 활용한다.</p>\n<ul>\n<li>실제 데이터 암호화 방식 : 대칭키</li>\n<li>상기 대칭키를 서로 공유하기 위한 암호화 방식 : 공개키</li>\n</ul>\n<h3 id=\"ssl-통신-과정\" style=\"position:relative;\"><a href=\"#ssl-%ED%86%B5%EC%8B%A0-%EA%B3%BC%EC%A0%95\" aria-label=\"ssl 통신 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SSL 통신 과정</h3>\n<p>컴퓨터와 컴퓨터가 네트워크를 통해 통신 할 때에는<code class=\"language-text\">핸드쉐이크 -&gt; 세션 -&gt; 세션 종료</code> 과정을 거치는데, 암호화된 HTTP 메시지를 교환하기 전에 클라이언트와 서버는 SSL 핸드쉐이크를 진행한다.</p>\n<p>핸드 쉐이크의 목적</p>\n<ul>\n<li>프로토콜 버전 교환</li>\n<li>양쪽이 알고 있는 pre master secret 키 생성 및 교환</li>\n<li>양쪽의 신원 인증</li>\n<li>채널을 암호화 하기 위한 임시 세션 키 생성</li>\n</ul>\n<h3 id=\"ssl에서-사용하는-암호화-종류\" style=\"position:relative;\"><a href=\"#ssl%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%95%94%ED%98%B8%ED%99%94-%EC%A2%85%EB%A5%98\" aria-label=\"ssl에서 사용하는 암호화 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SSL에서 사용하는 암호화 종류</h3>\n<ul>\n<li>암호 : 텍스트를 아무나 읽지 못하도록 인코딩하는 알고리즘</li>\n<li>키 : 암호의 동작을 변경하는 매개변수, 키에 따라 암호화 결과가 달라지기 때문에 키를 모르면 복호화가 불가능하다.</li>\n</ul>\n<h4 id=\"대칭키-암호화-방식\" style=\"position:relative;\"><a href=\"#%EB%8C%80%EC%B9%AD%ED%82%A4-%EC%95%94%ED%98%B8%ED%99%94-%EB%B0%A9%EC%8B%9D\" aria-label=\"대칭키 암호화 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>대칭키 암호화 방식</h4>\n<ul>\n<li>인코딩과 디코딩에 같은 키를 사용하는 알고리즘</li>\n<li>단점 : 발송자와 수신자가 서로 대화하려면 둘 다 공유키를 가져야 한다.</li>\n<li>대칭키를 전달하는 과정에서 키가 유출이 되면 암호의 내용을 복호화할 수 있기 때문에 위험하다.</li>\n<li>이를 보완하기 위해 나온 방법이 공개키 암호화 방식</li>\n</ul>\n<h4 id=\"공개키-암호화-방식\" style=\"position:relative;\"><a href=\"#%EA%B3%B5%EA%B0%9C%ED%82%A4-%EC%95%94%ED%98%B8%ED%99%94-%EB%B0%A9%EC%8B%9D\" aria-label=\"공개키 암호화 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>공개키 암호화 방식</h4>\n<ul>\n<li>인코딩과 디코딩에 다른 키를 사용하는 알고리즘</li>\n<li>A키로 암호화하면 B키로 복호화할 수 있다. 그 반대 역시 가능</li>\n<li>인코딩 키 (Public Key)는 공개되어 있으며, 보통 디지털 인증서 안에 포함되어 있다.</li>\n<li>디코딩 키 (Secret Key)는 호스트만이 개인 디코딩 키를 알고 있다.</li>\n<li>공개키와 비공개키의 분리는 메시지 인코딩은 누구나 할 수 있도록 해주는 동시에, 메시지의 디코딩을 비밀키 소유자에게만 부여한다.</li>\n<li>이는 클라이언트가 서버로 안전하게 메시지를 발송하는 것을 쉽게 해준다.</li>\n<li>단점 : 공개키 암호화 방식의 알고리즘을 계산이 느린 경향이 있다.</li>\n</ul>\n<h4 id=\"디지털-서명\" style=\"position:relative;\"><a href=\"#%EB%94%94%EC%A7%80%ED%84%B8-%EC%84%9C%EB%AA%85\" aria-label=\"디지털 서명 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>디지털 서명</h4>\n<ul>\n<li>전자 서명을 통해 누가 메시지를 썻고 메시지가 위조되지 않았음을 증명하는데 사용되며, SSL 인증서에서 서비스를 보증하는 방법으로 활용된다.</li>\n<li>공개키와 비공개키는 안전한 데이터 전달 이외에도, 데이터 제공자의 신원을 보장 하는데 사용할 수 있다.</li>\n<li>\n<p>순서</p>\n<ol>\n<li>비공개키의 소유자가 비공개 키를 이용해서 정보를 암호화</li>\n<li>공개키와 함께 암호화된 정보를 전송</li>\n<li>수신자는 공개키로 암호환된 정보를 복호화</li>\n</ol>\n</li>\n<li>암호화된 데이터를 공개키를 가지고 복호화 할 수 있다는 것은 그 데이터가 공개키와 쌍을 이루는 비공개키에 의해서 암호화가 되었다는 것을 의미한다.</li>\n<li>즉 공개키가 데이터를 제공한 사람의 신원을 보장해주게 되는 것이다.</li>\n</ul>\n<h3 id=\"ca-certificate-authority\" style=\"position:relative;\"><a href=\"#ca-certificate-authority\" aria-label=\"ca certificate authority permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CA (Certificate Authority)</h3>\n<ul>\n<li>디지털 인증서를 제공하는 공인된 기업 (Certificate Authority 혹은 Root Certificate)</li>\n<li>\n<p>대표적인 CA 서비스 제공 기업</p>\n<ul>\n<li>Symantec</li>\n<li>Comodo</li>\n<li>GoDaddy</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"jwt란\" style=\"position:relative;\"><a href=\"#jwt%EB%9E%80\" aria-label=\"jwt란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT란?</h2>\n<p>JWT은 웹표준으로서 두 개체 사이에서 JSON 객체를 사용하여 가볍고 자가수용적인 방식으로 정보를 <strong>안전성</strong> 있게 전달한다. JWT에 대해 알아보기 전에 JSON에 대해 알아보자.</p>\n<p>JSON (JavaScript Object Notation) 은 속성-값 쌍 혹은 키-값 쌍으로 이루어진 데이터 오브젝트를 전달하기 위해 인간이 읽을 수 있는 텍스트를 사용하는 개방형 표준 포맷이다. 비동기 브라우저/서버 통신 (Ajax)를 위해 넓게는 XML을 대체하는 주요 데이터 포맷이다. 특히 인터넷에서 자료를 주고 받을 때 그 자료를 표현하는 방법으로 알려져 있으며, 자료의 종류에는 큰 제한이 없어 변수값을 표현하는데 적합하다.</p>\n<p>ㅤ</p>\n<h2 id=\"구성-요소\" style=\"position:relative;\"><a href=\"#%EA%B5%AC%EC%84%B1-%EC%9A%94%EC%86%8C\" aria-label=\"구성 요소 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>구성 요소</h2>\n<p>JWT는 <code class=\"language-text\">.</code>을 구분자로 3가지의 문자열로 구성되어 있다.</p>\n<p>예) aaaa.bbbbb.cccc</p>\n<ul>\n<li>헤더 (header) : aaaaa</li>\n<li>내용 (payload) : bbbbb</li>\n<li>서명 (signature) : ccccc</li>\n</ul>\n<p>ㅤ</p>\n<h3 id=\"헤더-header\" style=\"position:relative;\"><a href=\"#%ED%97%A4%EB%8D%94-header\" aria-label=\"헤더 header permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>헤더 (header)</h3>\n<p>헤더는 <code class=\"language-text\">typ</code>, <code class=\"language-text\">alg</code> 두 가지의 정보를 지니고 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"typ\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"JWT\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"alg\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"HS256\"</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>typ : 토큰의 타입을 지정 JWT이기에 “JWT”라는 값이 들어간다.</li>\n<li>alg : 해싱 알고리즘을 지정 HMAC, SHA256, RSA가 사용되면 토근을 검증할 때 사용되는 signature 부분에서 사용된다.</li>\n</ul>\n<p>ㅤ</p>\n<h3 id=\"정보-payload\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%B3%B4-payload\" aria-label=\"정보 payload permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정보 (Payload)</h3>\n<p>Payload 부분에는 토큰을 담을 정보가 들어있다. 정보의 한 조각을 클레임(claim)이라고 부르고, 이는 name/value의 한 쌍으로 이뤄져있다. 토큰에는 여러 개의 클레임들을 넣을 수 있지만 많아질수록 토큰의 길이가 길어진다.</p>\n<p>클레임의 종류는 크게 세 분류로 나누어진다.</p>\n<ol>\n<li>\n<p><strong>등록된 (registered) 클레임</strong> : 서비스에서 필요한 정보들이 아닌, 토큰에 대한 정보들을 담기 위하여 이름이 이미 정해진 클레임이다. 등록된 클레임의 사용은 모두 선택(optional)이며, 이에 포함된 클레임은 다음과 같다.</p>\n<ul>\n<li><code class=\"language-text\">iss</code> : 토큰 발급자 (issuer)</li>\n<li><code class=\"language-text\">sub</code> : 토큰 제목 (subject)</li>\n<li><code class=\"language-text\">aud</code> : 토큰 대상자 (audience)</li>\n<li><code class=\"language-text\">exp</code> : 토큰의 만료시간(expiration), 시간은 NumericDate 형식으로 되어있어야 하며 언제나 현재 시간보다 이후로 설정되어 있어야 합니다.</li>\n<li><code class=\"language-text\">nbf</code> : Not before을 의미하며, 토큰의 활성 날짜와 비슷한 개념입니다. 여기에도 NumericDate형식으로 날짜를 지정하며, 이 날짜가 지정하며, 이 날짜가 지나기 전까지는 토큰이 처리되지 않습니다.</li>\n<li><code class=\"language-text\">iat</code> : 토큰이 발급된 시간(issued at), 이 값을 사용하여 토큰의 age가 얼마나 되었는지 판단 할 수 있습니다.</li>\n<li><code class=\"language-text\">jti</code> : JWT의 고유 식별자로서, 주로 중복적인 처리를 방지하기 위하여 사용됩니다. 일회용 토큰에 사용하면 유용합니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>공개 (public) 클레임</strong> : 공개 클ㅋ레임들은 충돌이 방지된 (collision-resistant) 이름을 가지고 있어야한다. 충돌을 방지하기 위해서는 클레임의 이름을 URL 형식으로 짓는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n <span class=\"token property\">\"https://aaa.com/jwt/is-active\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li><strong>비공개 (private) 클레임</strong> : 양 측간에 (보통 클라이언트와 서버) 합의하에 사용되는 클레임 이름들로 공개 클레임과는 달리 이름이 중복되어 충돌이 될 수 있으니 사용할 때 유의해야한다.</li>\n</ol>\n<p>ㅤ</p>\n<h3 id=\"서명-signatue\" style=\"position:relative;\"><a href=\"#%EC%84%9C%EB%AA%85-signatue\" aria-label=\"서명 signatue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>서명 (signatue)</h3>\n<p>서명은 헤더의 인코딩 값과 정보의 인코딩 값을 합친 후 주어진 비밀키로 해쉬를 하여 생성한다. 이렇게 만들어진 해쉬를 <code class=\"language-text\">base64</code> 형태로 나타낸다.</p>\n<h2 id=\"로그인-인증시-jwt-사용\" style=\"position:relative;\"><a href=\"#%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EC%9D%B8%EC%A6%9D%EC%8B%9C-jwt-%EC%82%AC%EC%9A%A9\" aria-label=\"로그인 인증시 jwt 사용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>로그인 인증시 JWT 사용</h2>\n<p>로그인 인증시에도 JWT를 사용한다. 주로 세션을 유지하기 위해서 사용하는데, 이 때 만약 유효기간이 짧은 Token을 발급하게 되면 사용자 입장에서 자주 로그인을 해야하기 때문에 번거롭고 반대로 유효기간이 긴 Token을 발급하게되면 제 3자에게 토큰을 탈취당할 수 있는 보안에 취약하다는 단점이 존재한다.</p>\n<p>이런 점을 보완하기 위해 Refresh Token을 사용하는데, Refresh Token은 앞서 로그인에서 발급했던 Access Token과 동일한 JWT 라는 점에서 Access Token의 유효기간이 만료되었을 때, Refresh Token이 새로 발급해주는 열쇠 역할을 한다. 예를 들어, Refresh Token의 유효기간은 1주, Access Token의 유효기간은 1시간이라고 한다면, 사용자는 Access Token으로 1시간동안 API요청을 하다가 시간이 만료되면 Refresh Token을 이용하여 새롭게 발급하면 된다.</p>\n<p>이 방법또한 Access Token이 탈취당한다해도 정보가 유출이 되는걸 막을 수 없지만, 더 짧은 유효기간때문에 탈취되는 가능성이 적다는 점을 이용한 것으로 Refresh Token 또한 유효기간이 만료됐다면, 사용자는 새로 로그인해야 하며, Refresh Token도 탈취 될 가능성이 있기 때문에 적절한 유효기간 설정이 필요하다.</p>","frontmatter":{"title":"네트워크 관련 용어 정리","date":"October 23, 2020"}}},"pageContext":{"slug":"/Backend/네트워크-관련-용어-정리/","previous":{"fields":{"slug":"/Backend/ci-cd-pipeline이란/"},"frontmatter":{"title":"CI/CD Pipeline이란","category":"Backend","draft":false}},"next":{"fields":{"slug":"/Kafka/aws-ec2에-kafka-cluter-구성/"},"frontmatter":{"title":"AWS EC2에 Kafka Cluter 구성","category":"Kafka","draft":false}}}},"staticQueryHashes":["2486386679","3128451518"]}