{"componentChunkName":"component---src-templates-blog-post-js","path":"/Backend/데이터베이스-관련-내용-정리/","result":{"data":{"site":{"siteMetadata":{"title":"MUSTNOT","author":"[mustnot]","siteUrl":"https://mustnot.github.io","comment":{"disqusShortName":"","utterances":"mustnot/mustnot.github.io"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"2b468250-db1d-5b4c-a6b3-c600ac1e551f","excerpt":"실행 계획(Execution Plan) DBMS의 쿼리 실행에 같은 결과를 만들어 내는 데 한가지 방법만 있는 것은 아니다. 아주 다양한 방법이 존재하고 그 중에 어떤 방법이 최적이고 최소 비용으로 동작할지 결정해야하는데, DBMS에는 쿼리를 최적으로 실행하기 위한 각 테이블의 데이터가 어떤 분포로 저장되어 있는지 통계 정보 등을 참조하여 이런 기본 데이터를 비교해 최적의 실행 계획을 수행하는 작업이 필요하다. 이런 역할은 DBMS에서는 옵티마이저 기능이 담당한다. MySQL…","html":"<h2 id=\"실행-계획execution-plan\" style=\"position:relative;\"><a href=\"#%EC%8B%A4%ED%96%89-%EA%B3%84%ED%9A%8Dexecution-plan\" aria-label=\"실행 계획execution plan permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>실행 계획(Execution Plan)</h2>\n<p>DBMS의 쿼리 실행에 같은 결과를 만들어 내는 데 한가지 방법만 있는 것은 아니다. 아주 다양한 방법이 존재하고 그 중에 어떤 방법이 최적이고 최소 비용으로 동작할지 결정해야하는데, DBMS에는 쿼리를 최적으로 실행하기 위한 각 테이블의 데이터가 어떤 분포로 저장되어 있는지 통계 정보 등을 참조하여 이런 기본 데이터를 비교해 최적의 실행 계획을 수행하는 작업이 필요하다. 이런 역할은 DBMS에서는 옵티마이저 기능이 담당한다.</p>\n<p>MySQL에서는 <code class=\"language-text\">EXPLAIN</code>이라는 명령으로 쿼리의 <strong>실행 계획</strong>을 확인할 수 있으며 많은 정보가 출력된다.</p>\n<p>ㅤ</p>\n<h3 id=\"실행-계획이란\" style=\"position:relative;\"><a href=\"#%EC%8B%A4%ED%96%89-%EA%B3%84%ED%9A%8D%EC%9D%B4%EB%9E%80\" aria-label=\"실행 계획이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>실행 계획이란?</h3>\n<p>어떤 DBMS든지 쿼리의 실행 계획을 수립하는 옵티마이저는 가장 복잡한 부분으로 알려져 있으며, 옵티마이저가 만들어 내는 실행 계획을 이해하는 것 또한 상당히 어려운 부분이다. 하지만 그 실행 계획을 이해할 수 있어야만 실행 계획의 불합리한 부분을 찾아내고 더욱 최적화된 방법으로 실행 계획을 수립하도록 유도할 수 있다.</p>\n<h4 id=\"쿼리-실행-절차\" style=\"position:relative;\"><a href=\"#%EC%BF%BC%EB%A6%AC-%EC%8B%A4%ED%96%89-%EC%A0%88%EC%B0%A8\" aria-label=\"쿼리 실행 절차 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>쿼리 실행 절차</h4>\n<p>MySQL 서버에서 쿼리가 실행되는 과정은 크게 3가지로 나눌 수 있다.</p>\n<ol>\n<li>SQL 파싱 (SQL 파서) : 사용자로부터 요청된 SQL 문장을 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리</li>\n<li>\n<p>최적화 및 실행 계획 수립 : SQL 파싱 정보를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택</p>\n<ul>\n<li>불필요한 조건의 제거 및 복잡한 연산의 단순화 등 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정하고 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정, 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정한다.</li>\n</ul>\n</li>\n<li>2에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.</li>\n</ol>\n<h3 id=\"옵티마이저의-종류\" style=\"position:relative;\"><a href=\"#%EC%98%B5%ED%8B%B0%EB%A7%88%EC%9D%B4%EC%A0%80%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-label=\"옵티마이저의 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>옵티마이저의 종류</h3>\n<p>옵티마이저는 데이터베이스 서버에 두뇌와 같은 역할을 담당하고 있는데, 옵티마이저는 현재 대부분의 DBMS가 선택하고 있는 비용 기반 최적화(Cost-based Optimizer, CBO) 방법과 예전 오라클에서 많이 사용했던 규칙 기반 최적화 방법 (Rule-based Optimizer, RBO) 으로 크게 나눌 수 있다.</p>\n<ul>\n<li>규칙 기반 최적화 : 기본적으로 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립</li>\n<li>비용 기반 최적화 : 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고, 각 단위 작업의 비용(부하) 정보와 대상 테이블의 예측된 통계 정보를 이용해 각 실행 계획별 비용을 산출</li>\n</ul>\n<h3 id=\"실행-계획-분석\" style=\"position:relative;\"><a href=\"#%EC%8B%A4%ED%96%89-%EA%B3%84%ED%9A%8D-%EB%B6%84%EC%84%9D\" aria-label=\"실행 계획 분석 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>실행 계획 분석</h3>\n<p>MySQL에서 쿼리의 실행 계획을 확인하려면 <code class=\"language-text\">EXPLAIN</code> 명령을 사용하면 된다. 아무런 옵션 없이 EXPLAIN 명령만 사용하면 기본적인 쿼리 실행 계획만 보인다. 하지만, <code class=\"language-text\">EXPLAIN EXTENDED</code>나 <code class=\"language-text\">EXPLAIN PARTITIONS</code> 명령을 이용해 더 상세한 실행 계획을 확인할 수 있다.</p>\n<p><code class=\"language-text\">EXPLAIN</code> 명령은 다음과 같이 <code class=\"language-text\">EXPLAIN</code> 키워드 뒤에 확인하고 싶은 <code class=\"language-text\">SELECT</code> 쿼리 문장을 작성하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"mysql\"><pre class=\"language-mysql\"><code class=\"language-mysql\">EXPLAIN\nSELECT uid\nFROM user\nWHERE account_type = &quot;google&quot;;</code></pre></div>\n<p>이렇게 실행하면 쿼리 문장의 특성에 따라 표 형태로 된 1줄 이상의 결과가 표시된다. 표의 각 라인(레코드)은 쿼리 문장에서 사용된 테이블(서브 쿼리로 임시 테이블을 생성한 경우 임시 테이블까지 포함)의 개수만큼 출력된다. 실행 순서는 위에서 아래로 순서대로 표시된다. 출력된 실행 계획에서 위쪽에서 출력된 결과일수록 쿼리의 바깥 부분이거나 가장 먼저 접근한 테이블이고, 아래쪽에 출력된 결과일수록 쿼리의 안쪽 부분 혹은 나중에 접근한 테이블에 해당된다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/52126612/97080187-9478fe80-1634-11eb-8191-657f9e1c9fcf.png\" alt=\"F2371513-ED54-4E38-AAA3-8481D6EA880D\"></p>\n<h3 id=\"컬럼-정보\" style=\"position:relative;\"><a href=\"#%EC%BB%AC%EB%9F%BC-%EC%A0%95%EB%B3%B4\" aria-label=\"컬럼 정보 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>컬럼 정보</h3>\n<ul>\n<li>\n<p><code class=\"language-text\">select_type</code> : 각 단위 <code class=\"language-text\">SELECT</code>가 어떤 타입의 쿼리인지 표시되는 컬럼</p>\n<ul>\n<li><code class=\"language-text\">SIMPLE</code> : 가장 단순한 <code class=\"language-text\">SELECT</code> 쿼리인 경우, <code class=\"language-text\">SIMPLE</code>로 표기된다.</li>\n<li><code class=\"language-text\">PRIMARY</code> : <code class=\"language-text\">UNION</code>이나 서브 쿼리가 포함된 <code class=\"language-text\">SELECT</code> 쿼리의 실행 계획에서 가장 바깥에 있는 단위 쿼리는 <code class=\"language-text\">select_type</code>이 <code class=\"language-text\">PRIMARY</code>로 표시된다.</li>\n<li><code class=\"language-text\">UNION</code> : <code class=\"language-text\">SELECT</code> 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 <code class=\"language-text\">SELECT</code> 쿼리의 <code class=\"language-text\">select_type</code>은 <code class=\"language-text\">UNION</code>으로 표시된다.</li>\n<li>.. 너무 많다</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"hint을-이용한-실행-계획-제어\" style=\"position:relative;\"><a href=\"#hint%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%8B%A4%ED%96%89-%EA%B3%84%ED%9A%8D-%EC%A0%9C%EC%96%B4\" aria-label=\"hint을 이용한 실행 계획 제어 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Hint을 이용한 실행 계획 제어</h2>\n<ol>\n<li><code class=\"language-text\">USE INDEX</code> : 사용자가 원하는 인덱스가 있는 경우 사용하며, 힌트가 항상 적용되는 것은 아니기에 옵티마이저가 잘못된 인덱스를 선택하여 사용하는 경우 유용하다.</li>\n<li><code class=\"language-text\">IGNORE INDEX</code> : 제외하고자 하는 인덱스가 있는 경우 사용하는데, 이것 역시 항상 적용되는 것은 아니다.</li>\n<li><code class=\"language-text\">FORCE INDEX</code> : 사용하기 원하는 인덱스가 있는 경우 사용하며, 옵티마이저가 선택할 수 없는 인덱스라고 판단되는 경우 선택한 인덱스를 무시하고 Table Full-Scan을 한다.</li>\n</ol>\n<br>\n<h2 id=\"index\" style=\"position:relative;\"><a href=\"#index\" aria-label=\"index permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Index</h2>\n<p>기본적인 개념을 살펴보면 다음과 같다. <strong>인덱스(Index)</strong>는 데이터베이스 분야에서 테이블에 대한 동작 속도를 높여주는 자료 구조를 일컫는다. 인덱스는 테이블 내의 1개의 컬럼 혹은 여러 개의 컬럼을 이용하여 생성될 수 있는데, 고속의 검색 뿐만 아니라 레코드 접근과 <u>효율적인 순서 매김 동작에 대한 기초</u>를 제공한다. 인덱스를 저장하는 데 필요한 디스크 공간은 보통 테이블을 저장하는 데 필요한 디스크 공간보다 적게 할애되는데, <strong>관계형 데이터베이스</strong>에서는 인덱스란 테이블 부분에 대한 하나의 사본 역할을 한다고 볼 수 있다.</p>\n<blockquote>\n<p>ℹ️ 인덱스를 저장하기 위해 디스크 공간이 테이블을 저장하는 디스크 공간보다 적게 할애되는 이유는 보통 인덱스는 키-필드만 갖고 있고, 테이블의 다른 세부 항목들은 갖고 있지 않기 때문이다.</p>\n</blockquote>\n<p>요약하면 데이터베이스 안의 레코드를 처음부터 풀 스캔하지 않고, <strong><u>B+ Tree</u></strong>로 구성된 구조에서 Index 파일 검색으로 속도를 향상시키는 기술이다.</p>\n<p>그렇다면, 속도 향상을 위해서 무조건 많이 설정하면 좋은걸까? 그건 아니다. 인덱스는 하나 혹은 여러 개의 컬럼에 대해 설정할 수 있고, 단일 인덱스를 여러 개 생성할 수도, 여러 컬럼을 묶어 복합 인덱스를 설정할 수도 있다. 그러나 무조건 많이 설정한다고 검색 속도를 월등히 높여주는 것은 아닌데, 인덱스는 데이터베이스 메모리를 사용하여 테이블 형태로 저장하기 때문에 개수와 저장 공간은 비례한다.</p>\n<p>ㅤ</p>\n<h3 id=\"index의-원리\" style=\"position:relative;\"><a href=\"#index%EC%9D%98-%EC%9B%90%EB%A6%AC\" aria-label=\"index의 원리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Index의 원리</h3>\n<p>테이블 생성시 3개의 파일이 다음과 같이 생성된다.</p>\n<ul>\n<li>FRM : 테이블 구조 저장 파일</li>\n<li>MYD : 실제 데이터 파일</li>\n<li>MYI : Index 정보 파일 (Index 사용 시 생성된다.)</li>\n</ul>\n<p>이렇게 생성된 3개의 파일 중 인덱스를 원하는 컬럼에 주게 되면, 위와 같이 초기에 생성된 3개의 파일 중 MYI에 해당 컬럼을 색인화하여 저장한다. 물론 인덱스를 사용하지 않는 경우 MYI 파일은 비어 있다. 그래서 SELECT 쿼리로 INDEX가 사용하는 쿼리를 사용시 해당 TABLE을 검색하는 것이 아닌 빠른 Tree로 정리해둔 MYI 파일의 내용을 검색한다.</p>\n<blockquote>\n<p>📌 공부하다가 갑자기 DML, DCL, DDL 의 차이가 헷갈려서 정리</p>\n<ul>\n<li>DML : Data Manipulation Language 데이터 조작어로 SELECT / INSERT / UPDATE / DELETE 등이 포함</li>\n<li>DDL : Data Definition Language 데이터 정의어로 CREATE / ALTER / DROP / RENAME / TRUNCATE 등</li>\n<li>DCL : Data Control Language 데이터 제어어로 GRANT / REVOKE</li>\n<li>TCL : Transaction Control Language 트랜잭션 제어어로 COMMIT / ROLLBACK / SAVEPOINT</li>\n</ul>\n</blockquote>\n<p>만약 인덱스를 사용하지 않은 SELECT 쿼리라면 해당 TABLE 을 Full Scan 하여 검색한다.</p>\n<p>ㅤ</p>\n<h3 id=\"index의-단점\" style=\"position:relative;\"><a href=\"#index%EC%9D%98-%EB%8B%A8%EC%A0%90\" aria-label=\"index의 단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Index의 단점</h3>\n<ul>\n<li>인덱스 생성시 .mdb 파일 크기가 증가한다.</li>\n<li>한 페이지를 동시에 수정할 수 있는 병행성이 줄어든다.</li>\n<li>인덱스 된 Field에서 Data를 업데이트하거나, Record를 추가 또는 삭제시 성능이 저하한다.</li>\n<li>데이터 변경 작업이 자주 일어나는 경우, Index를 재작성해야 하므로 성능에 영향을 미친다.</li>\n</ul>\n<p>ㅤ</p>\n<h3 id=\"index의-사용-상황\" style=\"position:relative;\"><a href=\"#index%EC%9D%98-%EC%82%AC%EC%9A%A9-%EC%83%81%ED%99%A9\" aria-label=\"index의 사용 상황 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Index의 사용 상황</h3>\n<h4 id=\"사용하면-좋은-경우\" style=\"position:relative;\"><a href=\"#%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4-%EC%A2%8B%EC%9D%80-%EA%B2%BD%EC%9A%B0\" aria-label=\"사용하면 좋은 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>사용하면 좋은 경우</h4>\n<ol>\n<li>Where 절에서 자주 사용되는 Column</li>\n<li>외래키가 사용되는 Column</li>\n<li>Join에서 자주 사용되는 Column</li>\n</ol>\n<p>ㅤ</p>\n<h4 id=\"피해야하는-경우\" style=\"position:relative;\"><a href=\"#%ED%94%BC%ED%95%B4%EC%95%BC%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0\" aria-label=\"피해야하는 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>피해야하는 경우</h4>\n<ol>\n<li>Data 중복도가 높은 컬럼</li>\n<li>\n<p>DML이 자주 일어나는 컬럼</p>\n<ul>\n<li>\n<p>INSERT : 기존 Block에 여유가 없을 경우, 새로운 Data가 입력된다.</p>\n<p>-> 새로운 Block을 할당 받은 후 Key를 옮기는 작업을 수행한다.</p>\n<p>-> Index split 작업 동안, 해당 Block의 Key 값에 대해 DML이 블로킹된다. (대기 이벤트 발생)</p>\n</li>\n<li>DELETE :</li>\n<li>Table에서 Data가 Delete 되는 경우 : Data가 지워지고, 다른 Data가 그 공간을 사용한다.</li>\n<li>\n<p>Index에서 Data가 Delete 되는 경우 : Data가 지워지지 않고, 사용 안 됨 표시만 해둔다.</p>\n<p>-> Table의 Data 수가 Index의 Data 수가 다를 수 있음</p>\n</li>\n<li>UPDATE :</li>\n<li>Table에서 Update가 발생하면, Index는 Update를 할 수 없다.</li>\n<li>Index에서는 Delete가 발생한 후, 새로운 작업의 Insert 작업 / 2 배의 작업이 소요되어 힘들다.</li>\n</ul>\n</li>\n</ol>\n<p>ㅤ</p>\n<h3 id=\"index-column-선택-방법\" style=\"position:relative;\"><a href=\"#index-column-%EC%84%A0%ED%83%9D-%EB%B0%A9%EB%B2%95\" aria-label=\"index column 선택 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Index Column 선택 방법</h3>\n<p>인덱스는 한 테이블 당 보통 3~5개 정도가 적당한데, 물론 테이블의 목적과 컬럼 수에 따라 개수는 달라질 수 있다. 인덱스는 컬럼을 정해서 설정하는 것으로 후보 컬럼의 특징을 잘 파악해야 하며, 아래 4가지 기준을 사용하면 효율적으로 인덱스를 설정할 수 있다.</p>\n<ol>\n<li><strong>카디널리티 (Cardinality) :</strong> 카디널리티란 전체 행에 대한 특정 컬럼의 중복 수치를 나타내는 지표로 대개 중복도가 ‘낮으면’ 카디널리티가 ‘높다’고 표현한다. 그러다보니 중복도가 낮은 컬럼이 인덱스 설정에 좋다.</li>\n<li><strong>선택도 (Selectivity) :</strong> 선택도가 낮을수록 인덱스 설정에 좋은 컬럼으로 데이터에서 특정 값을 얼마나 잘 선택할 수 있는지에 대한 지표</li>\n<li><strong>활용도 :</strong> 활용도가 높은 컬럼</li>\n<li><strong>중복도 :</strong> 중복도가 없을 수록 인덱스 설정에 좋은 컬럼이다.</li>\n</ol>\n<br>\n<p>Redis (Remote Dictionary Server) 는 In-Memory 데이터베이스로 모든 데이터를 메모리에 저장과 조회가 빠른 <strong>비관계형 데이터베이스</strong>이다. 키-값 데이터 구조를 갖고 있으며, 다양한 데이터 구조 집합을 제공하여 사용자 정의 어플리케이션을 손쉽게 생성할 수 있다.</p>\n<p>ㅤ</p>\n<h2 id=\"redis-vs-memcached\" style=\"position:relative;\"><a href=\"#redis-vs-memcached\" aria-label=\"redis vs memcached permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Redis vs Memcached</h2>\n<p><strong>Redis</strong>와 같은 메모리 캐싱 시스템으로 대표적으로 비교되는 것으로 <strong>Memcached</strong>가 있다. Redis를 사용하는 많은 이유를 설명하는 글의 대다수가 Memcached 보다 장점이 많다는 점을 설명하는 글이 많아 자세한 Memcahed에 장/단점을 파악하기 어려웠다.</p>\n<p><strong>Memcached</strong>도 역시 오픈 소스로 03년 개발되어 처음에는 펄(Perl)로 작성되었지만 현재는 C로 재개발되었다. Redis와 동일하게 메모리에 데이터를 저장하는 방식을 이용하는데, In-Memory 특징상 서버가 다운되면 저장되어 있던 데이터가 지워지는 휘발성을 갖고 있다.</p>\n<p>반면, Redis의 경우에는 Memcached와 동일하게 In-Memory 데이터베이스임에도 불구하고 복구할 수 있는 솔루션을 제공하여 서버가 다운되더라도 이전에 저장해놓은 데이터를 다시 사용할 수 있는 환경을 제공하는 안전성이 있다. 또한 Redis는 문자열 뿐만 아니라 <code class=\"language-text\">List, Set, Sorted Set, Hash, Bit Array, Hyperloglogs</code> 등 다양한 데이터 구조를 지원하여 보다 쉽게 정보를 제공할 수 있다.</p>\n<p>Redis만의 특징을 정리하면 다음과 같다.</p>\n<ol>\n<li><strong>다양한 데이터 구조</strong> : <code class=\"language-text\">String, List, ...</code> 등 다양한 데이터 구조를 지원한다.</li>\n<li><strong>Snapshots</strong> : In-Memory 데이터베이스라는 특성에서 벗어나 데이터를 디스크에 저장하여 파일로 보관이 가능하다. 장애 상황시 복구에 사용된다.</li>\n<li><strong>복제</strong> : Mast-Slaves 구조로 여러 개의 복제본을 만들 수 있어 데이터 읽기 구조를 확장하여 높은 가용성 클러스터를 제공한다.</li>\n<li><strong>트랜잭션</strong> : 데이터베이스 상태를 변경시키는 작업 단위를 의미하는 트랜잭션의 특징을 모두 갖고 있다.</li>\n<li><strong>Pub / Sub Message</strong> (Publish:발행 / Sub:구독) : 두 가지 방식의 메세지를 구분하여 검색이 가능하다. 따라서 높은 성능을 요구하는 채팅, 실시간 스트리밍, SNS 피드 그리고 서버상호 통신에 사용할 수 있다.</li>\n<li><strong>위치 기반 데이터 타입 지원</strong> : Redis는 실시간 위치 기반 데이터를 지원하여, 두 위치의 거리를 찾거나 사이에 있는 요소 찾기 등의 작업을 수행할 수 있다. 이를 활용한 지도 기반의 고성능 서비스를 제공할 수 있다.</li>\n</ol>\n<p>이처럼 Redis가 Memcached 보다 월등히 뛰어난 것처럼 보이나, Redis의 구조적으로 <code class=\"language-text\">싱글 쓰레드</code> 라는 단점이 있어, 1번에 1개의 명령만 실행 가능하다. 그래서, Memcached에서 사용하는 <code class=\"language-text\">멀티 쓰레드</code> 방식과 달리 모든 데이터를 가져온다던가 삭제한다는 명령어를 실행하게 되면 Memcached와 근본적으로 속도 차이가 존재하게 된다.</p>\n<p>ㅤ</p>\n<h3 id=\"commands\" style=\"position:relative;\"><a href=\"#commands\" aria-label=\"commands permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Commands</h3>\n<p>Redis를 처음 사용할 때 느낀점은 “매우 간단하다”라는 느낌이였는데, 딥하게 들어가면 사용법이 더 복잡해지겠지만, 간단한 응용 수준의 명령어는 매우 단순하고 직관적이라는 것을 느꼈다.</p>\n<h4 id=\"set-get\" style=\"position:relative;\"><a href=\"#set-get\" aria-label=\"set get permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>set, get</h4>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token operator\">></span> <span class=\"token builtin class-name\">set</span> today <span class=\"token number\">2020</span>-11-02\nOK\n<span class=\"token operator\">></span> get tody\n<span class=\"token string\">\"2020-11-02\"</span></code></pre></div>\n<h4 id=\"incr\" style=\"position:relative;\"><a href=\"#incr\" aria-label=\"incr permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>incr</h4>\n<p>위에서 <code class=\"language-text\">set</code>한 결과를 보면 알겠지만, Redis는 모든 값을 String 유형으로 저장한다. 그렇다면 정수형의 데이터를 저장했다면 매번 정수형으로 변환하여 작업해야하는가? 라는 생각이 들었는데, 그건 맞으나 만약 단순히 숫자를 증가시키고 감소시킨다면, <code class=\"language-text\">incr</code> 명령어로 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token operator\">></span> <span class=\"token builtin class-name\">set</span> number <span class=\"token number\">1000</span>\nOK\n<span class=\"token operator\">></span> incr number <span class=\"token number\">5</span>\n<span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">1005</span>\n<span class=\"token operator\">></span> get number\n<span class=\"token string\">\"1005\"</span>\n<span class=\"token operator\">></span> incrby number -5\n<span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> <span class=\"token number\">1000</span>\n<span class=\"token operator\">></span> get number\n<span class=\"token string\">\"1000\"</span></code></pre></div>\n<p>보면 알겠지만, <code class=\"language-text\">incr</code>, <code class=\"language-text\">incrby</code> 두 명령어로 수를 증가시키거나 감소시킬 수 있는데, 그 과정에서 값은 integer 형태로 변경되지만 다시 값을 가져올 때에는 string 형태로 변경되어 출력되는 걸 볼 수 있다.</p>\n<h4 id=\"nx-xx\" style=\"position:relative;\"><a href=\"#nx-xx\" aria-label=\"nx xx permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>nx, xx</h4>\n<p>키가 이미 존재하거나, 존재하지 않는 경우 데이터를 저장하게 하는 옵션이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&gt; set newkey newval nx\nOK\n&gt; set newkey newval xx\nOK</code></pre></div>","frontmatter":{"title":"데이터베이스 관련 내용 정리","date":"October 03, 2020"}}},"pageContext":{"slug":"/Backend/데이터베이스-관련-내용-정리/","previous":{"fields":{"slug":"/Django/django-rest-framework-시작하기/"},"frontmatter":{"title":"Django REST Framework 시작하기","category":"Django","draft":false}},"next":{"fields":{"slug":"/Backend/ci-cd-pipeline이란/"},"frontmatter":{"title":"CI/CD Pipeline이란","category":"Backend","draft":false}}}},"staticQueryHashes":["2486386679","3128451518"]}